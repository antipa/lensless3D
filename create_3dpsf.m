%% Optical model
% Setup volume
try gpuDevice
    gpu = 1;
catch
    gpu = 0;
end
zin = load('pco_zstack_distances.mat','z');
z1 = -max(zin.z);
z2 = -min(zin.z);

f = 2/(-1/z1-1/z2);
wx = 1;   %Width of aperture in mm
wy = 1;   %Height of aperture in mm

lens_ca = sqrt(wx^2+wy^2);
fno = f/lens_ca;



 %Compute wavefront curvatures
z1i = 1/(-1/z1-1/f);   %Apparent position of z1
z2i = 1/(-1/z2-1/f);   %Apparent position of z2

%% Determine sampling 
% Find the pixel size needed to nyquist sample the highest frequency
% generated by point sources at extreme positions

lambda = 550e-6;   %Do e'rything in mm
theta = atan(lens_ca/2/abs(z1i));
lambda_max = lambda/sin(theta);
px = lambda_max/2;   %Propagation pixel size, account for diagonal



% Setup camera specs
sensor_ds = 1/4;
cpx = .0065/sensor_ds; %Camera pixel size in microns
sensor_pix = [2048 2048]*sensor_ds;   %number of pixels
sensor_size = sensor_pix*cpx;   %mm
zi_vec = 1./(1./zin.z-1/f);   %Apparent position of z1
Z = 40;  %mask-sensor distance
% Create random lenslet surface

% Find the optimal lenslet focal length such that the image of the point
% sources through the main lens is defocused symmetrically about the
% sensor. This is found by solving the polynomial
% phi_star = argmin(2*Z*phi.^2 + (2*Z*(l1+l2)-2)*phi + l1*l2*2*Z-l1-l2); 
% s.t. phi_star > 0;
l1 = 1/z2i;
l2 = 1/z1i;
a = 2*Z;
b = (2*Z*(l1+l2)-2);
c = l1*l2*2*Z-l1-l2;
phi_star = (-b+sqrt(b^2-4*a*c))/(2*a);
f_micro = 1/phi_star;   %Lens focal length     

% Now that focal length is known, compute the average aperture
% Need to take into account magnification?
Res = .03;   %Desired object-space resolution
Res_main1 = Res*Z/abs(z1);   %Spot size at sensor
Res_main2 = Res*Z/abs(z2);
Fnum1 = Res_main1/1.22/lambda;
Fnum2 = Res_main2/1.22/lambda;
D1 = f_micro/Fnum1;
D2 = f_micro/Fnum2;
D_mean = D1/2+D2/2;
lenslet_distribution = 'uniform';
% switch lower(lenslet_distribution)
%     case('uniform')
%         nlenslets = round(prod(mask_size/D_mean));
%         lens_centers = randsample(subsiz(1)*subsiz(2),nlenslets);
%         [rows,cols] = ind2sub(subsiz,lens_centers);
%     case('poisson')
%         pts = poissonDisc(subsiz,D_mean/px*2/3,0,0);
%         rows = pts(:,1);
%         cols = pts(:,2);
%         nlenslets = numel(rows);
% end
% Propagate



thetax_max = atan(wx/2/abs(z2i));
thetay_max = atan(wy/2/abs(z2i));
%W = wx+2*Z*tan(thetax_max)*1.8;   %Include fudge factor for extra padding
%H = wy+2*Z*tan(thetay_max)*1.8;
W = sensor_size(2);
H = sensor_size(1);
%Make Wr have even number of samples
Wr = floor(W/px/2)*2*px;
Hr = floor(H/px/2)*2*px;
xm = -Wr/2:px:Wr/2;
ym = -Hr/2:px:Hr/2;
[Xm,Ym] = meshgrid(xm,ym);
fx = linspace(-1/2/px,1/2/px,numel(xm));
fy = linspace(-1/2/px,1/2/px,numel(ym));
[Fx,Fy] = meshgrid(fx,fy);
% Propagate spherical wave to double check

Rmask = sqrt(Xm.^2+Ym.^2);
aperture = abs(Xm)<wx/2 & abs(Ym)<wy/2;

tic
k = 2*pi/lambda;
rg = sqrt(Xm.^2+Ym.^2+Z^2);   %Radius for real space green function
hg = ifftshift((k/2/pi/1i).*(exp(1i*k*rg)./rg) .* (1+1i./(k*rg)) .* Z./rg);
%Hf = ifftshift(exp(1i*2*pi*Z/lambda * sqrt(1-(lambda*Fx).^2 - (lambda*Fy).^2)));
Hf = (fft2(hg));
%if gpu
%    Hf = gpuArray(Hf);
%end
%Rf = sqrt(Fx.^2 + Fy.^2);
%Hf(Rf>1/lambda) = 0;
%ffiltx = sin(Fx*pi/max(Fx(:)))./(Fx.*pi/max(Fx(:)));
%ffilty = sin(Fy*pi/max(Fy(:)))./(Fy.*pi/max(Fy(:)));
%ffilt = (ffiltx.*ffilty).^2;
%ffilt = fftshift(ffilt);
%Hf = ffilt.*Hf;
for n = 1:length(zi_vec)
    zi = zi_vec(n)*1e16;
    R = sign(zi)*sqrt(Xm.^2+Ym.^2+zi.^2);
    Ui = exp(-1i*2*pi/lambda*R).*aperture;
    %Ui = zeros(size(R));
    %Ui(667, 667) = 1;
    %Ui(667, 667 + 2) = 1;
   % if gpu
    %    Ui = gpuArray(Ui);
    %end
    Ui = fft2(Ui);
    %Ui = gpuArray(Hf.*Ui);%gather(fftshift(fft2(fftshift(Ui)))));
    %Ui = gpuArray(Hf.*Ui);
    %clear Ui;

    %P = Ui_spect.*Hf;
    Ui = Ui.*Hf;
    pause(1/10);
    Ui = ifft2(Ui);
    %Ui = ifftshift(Ui);
    toc
    %p = ifftshift(ifft2(ifftshift((Ui.*Hf))));
    imagesc(abs(Ui).^2);
    axis image
    drawnow
end

%% Prepare volume
im_file = 'isl1actinCy3Top3_isl1.tif';
stack_info = imfinfo(im_file);
K = numel(stack_info);
ds_lateral = 1/2;   %Downsample factors
ds_axial = 1/2;
im_stack = zeros(ds_lateral*stack_info(1).Height,...
    ds_lateral*stack_info(1).Width,...
    ds_axial*K);
for k = 1:K*ds_axial
   im_stack(:,:,k) = imresize(double(imread(im_file,k,'Info',stack_info)),ds_lateral,'box'); 
end
density = 5;   %
cutoff = prctile(im_stack(:),100-density);
imstack_thresh = im_stack.*(im_stack>cutoff);

%% Scaled gaussian noise

%% Scaled uniform noise

%% Scaled bernouli

%% Uniform random lenslets

%% Poisson random lenslets

