%% Optical model
% Setup volume
try gpuDevice
    gpu = 1;
catch
    gpu = 0;
end
zin = load('pco_zstack_distances.mat','z');
z1 = -max(zin.z);
z2 = -min(zin.z);

f = 2/(-1/z1-1/z2);
wy = 6;   %Width of aperture in mm
wx = wy*1.25;   %Height of aperture in mm

lens_ca = sqrt(wx^2+wy^2);
fno = f/lens_ca;



%Compute wavefront curvatures
z1i = 1/(-1/z1-1/f);   %Apparent position of z1
z2i = 1/(-1/z2-1/f);   %Apparent position of z2

%% Determine sampling
% Find the pixel size needed to nyquist sample the highest frequency
% generated by point sources at extreme positions

lambda = 550e-6;   %Do e'rything in mm
theta = atan(lens_ca/2/abs(z1i));
lambda_max = lambda/sin(theta);
px = lambda_max/2;   %Propagation pixel size, account for diagonal



% Setup camera specs
sensor_ds = 1/4;
cpx = .0065/sensor_ds; %Camera pixel size in microns
sensor_pix = [2048 2048]*sensor_ds;   %number of pixels
sensor_size = sensor_pix*cpx;   %mm
zi_vec = 1./(1./zin.z-1/f);   %Apparent position of z1
Z = 8.8;  %mask-sensor distance
% Create random lenslet surface

% Find the optimal lenslet focal length such that the image of the point
% sources through the main lens is defocused symmetrically about the
% sensor. This is found by solving the polynomial
% phi_star = argmin(2*Z*phi.^2 + (2*Z*(l1+l2)-2)*phi + l1*l2*2*Z-l1-l2);
% s.t. phi_star > 0;
l1 = 1/z2i;
l2 = 1/z1i;
a = 2*Z;
b = (2*Z*(l1+l2)-2);
c = l1*l2*2*Z-l1-l2;
phi_star = (-b+sqrt(b^2-4*a*c))/(2*a);
f_micro = 1/phi_star;   %Lens focal length


%%  Setup grid sizes and aperture


% Determine sampling grid first
thetax_max = atan(wx/2/abs(z2i));
thetay_max = atan(wy/2/abs(z2i));
%W = wx+2*Z*tan(thetax_max)*1.8;   %Include fudge factor for extra padding
%H = wy+2*Z*tan(thetay_max)*1.8;
W = sensor_size(2);
H = sensor_size(1);
%Make Wr have even number of samples
Wr = floor(W/px/2)*2*px;
Hr = floor(H/px/2)*2*px;
xm = -Wr/2:px:Wr/2;
ym = -Hr/2:px:Hr/2;
[Xm,Ym] = meshgrid(xm,ym);
fx = linspace(-1/2/px,1/2/px,numel(xm));
fy = linspace(-1/2/px,1/2/px,numel(ym));
[Fx,Fy] = meshgrid(fx,fy);
% Propagate spherical wave to double check

Rmask = sqrt(Xm.^2+Ym.^2);
aperture = abs(Xm)<wx/2 & abs(Ym)<wy/2;

%% Calculate random lenslet focal length
subx = -wx/2:px:wx/2;
suby = -wy/2:px:wy/2;

% Now that focal length is known, compute the average aperture
% Need to take into account magnification?
Res = .03;   %Desired image space frequencies
Res_main1 = Res; %*Z/abs(z1);   %Spot size at sensor
Res_main2 = Res;  %*Z/abs(z2);
Fnum1 = Res_main1/1.22/lambda;
Fnum2 = Res_main2/1.22/lambda;
D1 = f_micro/Fnum1;
D2 = f_micro/Fnum2;
D_mean = min(D1,D2);
lenslet_distribution = 'uniform';
mask_size = [wy wx];
subsiz = [length(suby) length(subx)];
switch lower(lenslet_distribution)
    case('uniform')
        nlenslets = round(prod(mask_size/D_mean));
        lens_centers = randsample(subsiz(1)*subsiz(2),nlenslets);
        [rows,cols] = ind2sub(subsiz,lens_centers);
    case('poisson')
        pts = poissonDisc(subsiz,D_mean/px*2/3,0,0);
        rows = pts(:,1);
        cols = pts(:,2);
        nlenslets = numel(rows);
end

% Generate lenslets
index = 1.51;
index_prime = 1;
dn = index_prime-index;
Rl = f_micro*dn;
%Sphere: z = sqrt(1-(x-x0)^2/R^2 + (y-y0)^2/R^2)
%suby = linspace(-floor(subsiz(1)/2)*px,floor(subsiz(1)/2)*px,subsiz(1));
%subx = linspace(-floor(subsiz(2)/2)*px,floor(subsiz(2)/2)*px,subsiz(2));
[Xsub, Ysub] = meshgrid(subx,suby);
x0 = ([rows, cols] - floor(subsiz/2))*px;
sph = @(x0,y0,R)sqrt(R^2-(Xsub-x0).^2 - (Ysub-y0).^2);

padsiz = [00,000];
circpad = @(x)padarray(x,padsiz,'both');
circcrop = @(x)x(padsiz(1)+1:end-padsiz(1),padsiz(2)+1:end-padsiz(2));
sph_pre = circpad(sph(0,0,Rl));

lenslet_surface = zeros(size(Xsub));
h1 = figure(1),clf
gifcount = 0;
    tic
for n = 1:length(lens_centers)

    %zt = sph(x0(n,2),x0(n,1),Rl);
    zt = (circshift(sph_pre,[rows(n) cols(n)]-floor(subsiz/2)));
    lenslet_surface = max(real(zt),lenslet_surface);
    
    if mod(n,50)==0
        toc*(nlenslets-n)/50
        gifcount = gifcount+1
        imagesc(lenslet_surface)
        hold on
        scatter(cols(n),rows(n),'k+')
        hold off
        colormap parula
        axis image
        drawnow
        frame = getframe(h1);
        im = frame2im(frame);
        [imind,cm] = rgb2ind(im,256);
        filename = 'uniform_lenslet_gif2.gif';
        if gifcount == 1
            imwrite(imind,cm,filename,'gif', 'Loopcount',inf);
        else
            imwrite(imind,cm,filename,'gif','WriteMode','append');
        end
        tic
    end

end

%%


tic
k = 2*pi/lambda;
%rg = sqrt(Xm.^2+Ym.^2+Z^2);
%greenFunc = @(Zprop)generate_greenfunc(Xm,Ym,Zprop,lambda);
%Zoff = 2000;
%h1 = greenFunc(Z+Zoff);
%h2 = greenFunc(-Zoff);   %Propagate far away, then propagate back?
%imagesc(angle(h2));


%H1 = fft2(ifftshift(h1));
%H2 = fft2(ifftshift(h2));
%rg = sqrt(Xm.^2+Ym.^2+Z^2);   %Radius for real space green function
%hg = ((k/2/pi/1i).*(exp(1i*k*rg)./rg) .* (1+1i./(k*rg)) .* Z./rg);
Hf = fftshift(exp(1i*k*Z * sqrt(1-(lambda*Fx).^2 - (lambda*Fy).^2)));


%Hf = (fft2(hg));
if gpu
    Hf = gpuArray(Hf);
end
Rf = ifftshift(sqrt(Fx.^2 + Fy.^2));
Hf(Rf>(1/lambda)) = 0;
%imagesc(abs(angle(Hf).*abs(Hf)));%
%%
ffiltx = sin(Fx*pi/max(Fx(:)))./(Fx.*pi/max(Fx(:)));
ffilty = sin(Fy*pi/max(Fy(:)))./(Fy.*pi/max(Fy(:)));
ffilt = (ffiltx.*ffilty).^2;
ffilt = ifftshift(ffilt);
ffilt(isnan(ffilt)) = 1;
%Hf = ffilt.*Hf;
for n = 1:length(zi_vec)
    zi = zi_vec(end-n);
    R = sign(zi)*sqrt(Xm.^2+Ym.^2+zi.^2);
    Ui = exp(-1i*2*pi/lambda*R).*aperture;
    %Ui = zeros(size(R));
    %Ui(667, 667-6) = 1;
    %Ui(667, 667) = 1;
    if gpu
        Ui = gpuArray(Ui);
    end
    Ui = fft2(ifftshift(Ui));
    %Ui = gpuArray(Hf.*Ui);%gather(fftshift(fft2(fftshift(Ui)))));
    %Ui = gpuArray(Hf.*Ui);
    %clear Ui;
    %P = Ui_spect.*Hf;
    Ui = Ui.*Hf;
    pause(1/10);
    Ui = ifft2(Ui);
    Ui = ifftshift(Ui);
    %Up = ifftshift(ifft2(Ui));
    %Ui = ifftshift(Ui);
    toc
    %p = ifftshift(ifft2(ifftshift((Ui.*Hf))));
    imagesc(abs(Ui).^2);
    axis image
    drawnow
end

%% Prepare volume
im_file = 'isl1actinCy3Top3_isl1.tif';
stack_info = imfinfo(im_file);
K = numel(stack_info);
ds_lateral = 1/2;   %Downsample factors
ds_axial = 1/2;
im_stack = zeros(ds_lateral*stack_info(1).Height,...
    ds_lateral*stack_info(1).Width,...
    ds_axial*K);
for k = 1:K*ds_axial
    im_stack(:,:,k) = imresize(double(imread(im_file,k,'Info',stack_info)),ds_lateral,'box');
end
density = 5;   %
cutoff = prctile(im_stack(:),100-density);
imstack_thresh = im_stack.*(im_stack>cutoff);

%% Scaled gaussian noise

%% Scaled uniform noise

%% Scaled bernouli

%% Uniform random lenslets

%% Poisson random lenslets

